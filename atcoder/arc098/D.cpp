#include <cstdio>
#include <iostream>
using namespace std;
int N, A[200005];
long long result;

/*
규칙을 잘 보면 연속된 구간의 합이랑 XOR이 같으려면 각각의 숫자들의 비트가 중복되는게 없어야 한다.
1, 2, 4, 8 처럼 서로 비트 중복이 없어야 합이랑 XOR이랑 같다는 뜻이다.
숫자도 최대 2 ^ 20 - 1까지라서 비트 중복없이 최대 연속 구간은 20개 정도라서 O(N ^ 2)로 해결
가능 하지만 조건을 보면 0도 나온다. 0은 모든 수들의 합과 XOR을 같게 만들기 때문에
주어진 수들중에서 0이 포함 되면 최대 연속구간이 20개에서 최대 N까지 만들기 때문에 O(N ^ 2)로는
시간초과가 나게 된다. 잘 보면 어떤 구간이 구간의합과 XOR이 같다면 맨앞의 수를 제외해도 변함이 없다.
이 규칙을 이용하여 투포인터로 0 부터 10까지 최대 연속 구간이라면 1부터 10까지 갈 필요 없이
1부터 10은 어차피 합이랑 XOR이 같기 때문에 해당 길이 만큼 더하고 10부터 다시 탐색을 하면 된다.
*/

int main()
{
    scanf("%d", &N);
    for(int i = 0; i < N; i++)
    {
        scanf("%d", &A[i]);
    }
    int l, r, hap = 0;
    l = 0;
    r = 0;
    while(l <= r && l < N)
    {
        //합이랑 XOR이 같다는건 &연산이 0이라는 뜻
        //합이랑 XOR이 같다면 그다음으로 탐색
        if(r < N && (hap & A[r]) == 0)
        {
            result++;
            hap += A[r++];
        }
        //다르다면 왼쪽을 하나 늘림
        else
        {
            //길이만큼 더함
            result += r - l - 1;
            hap -= A[l++];
        }
    }
    printf("%lld", result);
}
