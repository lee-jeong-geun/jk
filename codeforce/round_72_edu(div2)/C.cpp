#include <bits/stdc++.h>
using namespace std;
int Sum[200005], result, length;
char s[200005];

/*
임의의 연속된 구간과 그 구간에 속한 비트의 값이 같은 구간이 몇개인지 찾아야 한다.
예를 들어 011은 길이가 3이고 비트의 값도 3이다.
그리고 0100은 길이가 4이고 비트의 값도 4이다.
규칙을 잘 보면 길이는 최대 20만이고 나올 수 있는 값의 최대도 20만 정도다.
20만은 대략 2^18정도다. 즉 어떤 구간이든 길이가 18을 넘길 수 없다는 것이다.
왜냐하면 길이가 18을 넘긴다는 것은 비트의 값이 20만 보다 커질 수 있다는 것이고
비트의 값이 20만 보다 커진다는 것은 구간의 길이를 20만보다 더 길게 봐야 된다는 것인데
최대 길이는 20만 까지이므로 볼 수 없다.
각 구간의 시작점을 우측으로 잡아서 좌측으로 하나씩 길이를 늘리면서 최대 18칸 까지만 본다.
이때 문제가 있는데 만약 비트의 값이 71234일 때 길이가 71234인 구간 전체를 확인하면서 구간의 비트의 값이
71234인지 빠르게 확인해야 한다. 구간 전체를 돌면서 확인하는 경우 전체 시간복잡도가 O(N ^ 2)되므로 시간 초과가 난다.
따라서 빠르게 확인해야 하는데 1의 개수에 대한 부분합을 이용하면 쉽게 확인 가능하다.
비트의 값이 15자리를 확인 했는데 71234가 나온 경우 71234 - 15의 1의 개수가 0이라면 결과값에 1 더해주면 된다.
*/

int main()
{
    int t;
    scanf("%d", &t);
    for(int tc = 0; tc < t; tc++)
    {
        result = 0;
        memset(Sum, 0, sizeof Sum);
        scanf("%s", s);
        length = strlen(s);
        for(int i = 0; i < length; i++)
        {
            Sum[i + 1] = Sum[i] + s[i] - '0';
        }
        for(int i = length - 1; i >= 0; i--)
        {
            int count = 0, idx = 0;
            //좌측 18자리 까지만 확인
            for(int j = i; j >= i - 18; j--, idx++)
            {
                //0을 넘어가면 종료
                if(j < 0)
                    break;
                //1만 확인함
                if(s[j] == '0')
                    continue;
                count += (1 << idx);
                if(j == i)
                    result++;
                //확인을 안하는 구간이 0인 경우
                else if(i - count + 1 >= 0 && Sum[j] - Sum[i - count + 1] == 0)
                    result++;
            }
        }
        printf("%d\n", result);
    }
}